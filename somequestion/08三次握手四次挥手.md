## TCP三次握手和四次挥手

https://blog.csdn.net/qq_38950316/article/details/81087809

### 详细图解

![img](https://img-blog.csdn.net/20180717201939345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**序列号seq：**

占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

**确认号ack：**

占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；**序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；**因此当前报文段最后一个字节的编号+1即为确认号。

**确认ACK：**

占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

**同步SYN：**

连接建立时用于同步序号。**当SYN=1，ACK=0时表示：这是一个连接请求报文段。**若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，**SYN=1表示这是一个连接请求，或连接接受报文**。**SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。**

**终止FIN：**

用来释放一个连接。FIN=1表示：此报文段的发送方的**数据已经发送完毕，并要求释放运输连接。**

**PS：**ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

```
字段		   含义
URG			紧急指针是否有效。为1，表示某一位需要被优先处理
ACK			确认号是否有效，一般置为1。
PSH			提示接收端应用程序立即从TCP缓冲区把数据读走。
RST			对方要求重新建立连接，复位。
SYN			请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN    		希望断开连接。
```



### 三次握手

TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。

**原理：**

1）客户端首先发送一个带有SYN标志地数据包给接收方，SYN=1，ACK=0 时表示：这是一个连接请求报文段。进入**SYN_SENT**状态，等待服务器确认

2）服务器接收后，必须确认客户的SYN（ack=x+1），同意连接，则在响应报文段中使得SYN=1，ACK=1。回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。

3）客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），，代表我知道了，此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态，完成三次握手。

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**通俗的说法：**

1）Client：嘿，李四，是我，听到了吗？

2）Server：我听到了，你能听到我的吗?

3）Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。

**为什么三次：**

**为了确保双方都具有收发数据的能力**；3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

两次不安全

四次没必要



### 四次挥手

当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。

**原理：**

1）客户端进程**发出连接释放报文，并且停止发送数据**。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，**客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。**

3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，**等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）**。
4）服务器将最后的数据发送完毕后，就**向客户端发送连接释放报文**，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，**服务器结束TCP连接的时间要比客户端早一些**。

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**通俗的说法：**

1）Client：我所有东西都说完了

2）Server：我已经全部听到了，但是等等我，我还没说完

3）Server：好了，我已经说完了

4）Client：好的，那我们的通信结束l

**为什么四次：**

因为被动关闭方，收到FIN请求报文后，立即进行ACK回复，接下来需要等待用户调用close接口进行确认，
缓冲区中的数据已经处理完毕，才会向对方发送FIN请求报文，得到ACK回复后，则直接释放socket.
因此被动关闭方的ACK和FIN不能直接放在一起回复。



### 三次四次？？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。**只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。**



### TIME_WAIT状态要经过2MSL(最大报文段生存时间)才到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想**网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。**在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。**MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。**如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。



### 握手失败如何处理：

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

服务端等待最后一个ACK报文超时后，向客户端回复RST报文，然后关闭释放socket
